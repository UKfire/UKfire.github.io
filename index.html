<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>leixi&#39;s Blog</title>
  <meta name="author" content="kefan.wkf">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="leixi&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">leixi&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>leixi&#39;s Blog<span class="blink-fast">∎</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart blink-slow"></i>
      Keep and carry on.
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/07/15/我理解的PPP-VISITOR模式和双重分发/" title="需要向类层次结构中增加新的方法，但是增加起来会很费劲或者会破坏设计。">我理解的PPP-VISITOR模式和双重分发</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-07-15  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>假如有一个Modem对象的层次结构，基类中具有对于所有调制解调器来说公用的方法。不同的派生类代表针对不同调制解调器厂商和类型的驱动程序。如果这时候要向层次结构中加一个新方法，比如适配unix，这个方法在不同的调制解调器中有自己的实现，那么后面如果又要适配windows该怎么办呢？</p>
<p>VISITOR模式的作用就是允许在不更改现有类层次结构的情况下向其中增加新方法。</p>
<p>如下代码很清晰的展示了Visitor模式和双重分发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Modem</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dial</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">recv</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(ModemVisitor v)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ModemVisitor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(HayesModem modem)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ZoomModem modem)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HayesModem</span> <span class="keyword">implements</span> <span class="title">Modem</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dial</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">recv</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ModemVisitor v)</span> </span>&#123;v.visit(<span class="keyword">this</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoomModem</span> <span class="keyword">implements</span> <span class="title">Modem</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dial</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">recv</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ModemVisitor v)</span> </span>&#123;v.visit(<span class="keyword">this</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnixModemConfigurator</span> <span class="keyword">implements</span> <span class="title">ModemVisitor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(HayesModem m)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ZoomModem m)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Modem是调制解调器的基类，所有基础方法都定义在里面，HayesModem和ZoomModem是派生类，这时候需要调制Unix的机器，只需要派生一个UnixModemConfigurator实现MedemVisitor，分别处理多态的visit方法即可，如果要调制Windows，只需要派生WindowsModemConfigurator即可。</p>
<p>这里之所以被称为双重分发是因为它涉及了两个多态分发。第一个分发是accept函数，该分发辨别了所调用的accept方法所属对象的类型。第二个是visit方法，它辨别出要执行的特定函数。</p>

	
	</div>
  <a type="button" href="/2018/07/15/我理解的PPP-VISITOR模式和双重分发/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/07/02/python2.7不支持SNI引发的问题/" >python2.7不支持SNI引发的问题</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-07-02  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h4 id="一、问题所在"><a href="#一、问题所在" class="headerlink" title="一、问题所在"></a>一、问题所在</h4><p>在爬取一个网站的图片时碰到https的图片没有办法通过requests.get方法获取到返回的二进制，并报了<code>requests.exceptions.SSLError: HTTPSConnectionPool</code>的错误，不解，查了一下，发现是因为python2.7不支持SNI导致的。</p>
<p>这个SNI是什么呢？因为有的网站多个域名复用一个ip，而当浏览器访问一个https站点时，会首先和服务器建立SSL连接，建立SSL连接的第一步时请求服务器证书。服务器在发送证书时，不知道浏览器请求的是哪个域名，所以不能根据不同域名发送不同的证书。这个时候SNI（Server Name Indication）就是为了解决这个问题的，它的工作原理是：在连接到服务器建立SSL连接之前，先发送要访问站点的域名，这样服务器就会根据这个域名返回一个合格证书。</p>
<p>然饿，悲剧是有很多啊，其中一个就是python2不支持SNI，所以在<code>request.get(url)</code>的时候，就报了上面那个错：<code>requests.exceptions.SSLError: HTTPSConnectionPool</code>。</p>
<h4 id="二、修改方法"><a href="#二、修改方法" class="headerlink" title="二、修改方法"></a>二、修改方法</h4><p>我亲测有效的修改方法有两种：</p>
<p><code>第一种</code>是取消对证书的验证，这个很简单啊，就是在request.get的参数中加一个verfy=False，也就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.get(url,verify=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>第二种</code>是想办法让python2支持SNI功能啊，需要pip安装以下依赖，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install ndg-httpsclient</span><br><span class="line">pip install pyasn1</span><br></pre></td></tr></table></figure></p>
<p>然后在使用requests之前注入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3.contrib.pyopenssl</span><br><span class="line">urllib3.contrib.pyopenssl.inject_into_urllib3()</span><br></pre></td></tr></table></figure>
<p>被安排的明明白白啊。</p>

	
	</div>
  <a type="button" href="/2018/07/02/python2.7不支持SNI引发的问题/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/06/21/我理解的PPP-有限状态机和STATE模式/" title="有限状态机是现实生活中很多模型的抽象，能利用好有限状态机模型能将很多复杂的逻辑清晰的表述出来">我理解的PPP-有限状态机和STATE模式</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-06-21  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h6 id="十字门有限状态机模型"><a href="#十字门有限状态机模型" class="headerlink" title="十字门有限状态机模型"></a>十字门有限状态机模型</h6><p><img src="https://ytying.com/img/turnstilebefore.png" alt="十字门有限状态机"></p>
<p>在上图十字门的操作中，可以找到一个简单的有限状态机（Finite State Machine），这个状态转移图，由3部分组成，圆形的称为状态，箭头上面的字，前面的表示事件，后面的称为动作。所以这个状态转移图表示的含义为：</p>
<p>1、若状态机在Locked状态下收到一个coin事件，则迁移到Unlocked状态并执行unlock动作。</p>
<p>2、若状态极在Unlocked状态下收到一个pass事件，则迁移到Locked状态并执行lock动作。</p>
<p>但是这个状态机有严重的漏洞，你们知道是什么吗？</p>
<p>那就是，在Unlocked状态下没有处理coin事件的迁移，和在Locked状态下没有处理pass事件的迁移，所以看下图这个修正版本：</p>
<p><img src="https://ytying.com/img/turnstileafter.png" alt="修改后的十字门有限状态机"></p>
<p>如果乘客在首次投币后继续多投了硬币，状态机就保持在Unlocked状态并提示一个小绿灯显示“thank you”，如果有乘客想在Unlocked的时候强行通过，那么状态机会保持在Locked的状态并响起警报。</p>
<h6 id="实现有限状态机的三种方式"><a href="#实现有限状态机的三种方式" class="headerlink" title="实现有限状态机的三种方式"></a>实现有限状态机的三种方式</h6><p>实习有限状态机（FSM）有三种方法，分别为<strong>嵌套swtich/case法</strong>，<strong>状态迁移表遍历法</strong>和<strong>STATE模式</strong></p>
<h6 id="嵌套switch-case法"><a href="#嵌套switch-case法" class="headerlink" title="嵌套switch/case法"></a>嵌套switch/case法</h6><p>我们先介绍一种简单常用的方法：switch/case嵌套，这种方式实现很简单，就是利用嵌套switch/case语句把代码分成了4个互斥的区域，每个区域对应状态转移表中的一项迁移，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">event</span> <span class="params">(<span class="keyword">int</span> event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> LOCKED:</span><br><span class="line">            <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">                <span class="keyword">case</span> COIN:</span><br><span class="line">                    state = UNLOCKED;</span><br><span class="line">                    unlock();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> PASS:</span><br><span class="line">                    ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UNLOCKED:</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个区域在需要时都会更改状态机的状态，然后调用相应的动作函数。例如：关于Locked和Coin的区域会把状态改为Unlocked并调用unlock()函数。</p>
<p>对于简单的状态机来说，嵌套switch/case的实现既简单又好用，所有的状态事件都出现在一两页代码中。然而，对于大型状态机来说，把具有大量状态和事件的代码退化成一页页的case语句。维护冗长、嵌套的switch/case语句就是一个非常困难且容易出错的工作了。</p>
<h6 id="状态迁移表遍历法"><a href="#状态迁移表遍历法" class="headerlink" title="状态迁移表遍历法"></a>状态迁移表遍历法</h6><p>第二种方法是状态迁移表遍历法，维护一个解释迁移表，在event函数中，会查找与事件匹配的迁移，并调用相应动作，并更改状态，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Turnstile</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    addTransition(LOCKED, COIN, UNLOCKED, unlock());</span><br><span class="line">    addTransition(LOCKED, PASS, LOCKED, alarm());</span><br><span class="line">    addTransition(UNLOCKED, COIN, UNLOCKED, thank());</span><br><span class="line">    addTransition(UNLOCKED, PASS, LOCKED, lock());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">event</span><span class="params">(<span class="keyword">int</span> event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Transition transition : transitions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == transition.currentState &amp;&amp; event == transition.event) &#123;</span><br><span class="line">            state = transition.newState();</span><br><span class="line">            transition.action.execute();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种实现方法有一个很大的好处，那就是构建迁移表的代码读起来就像一个规范的状态转移表。其中4行addTransition语句非常容易理解。状态机的逻辑全部集中在一个地方。和嵌套switch/case相比，维护这样一个有限状态机很容易，要增加新的迁移，只要向Turnstile的构造函数中增加一行addTransition语句即可。</p>
<p>而这种方法的代价就是速度感人，因为event函数要便利这个迁移表，对于大型状态机来说，这个遍历时间就会变得相当可观。</p>
<h6 id="STATE模式"><a href="#STATE模式" class="headerlink" title="STATE模式"></a>STATE模式</h6><p>第三种方法，也就是PPP中重点说明的STATE模式，将状态类抽象成一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TurnstileState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">coin</span><span class="params">(Turnstile t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(Turnstile t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后不同的状态分别实现这个接口，实现不同的事件处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockedTurnstileState</span> <span class="keyword">implements</span> <span class="title">TurnstileState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coin</span><span class="params">(Turnstile t)</span> </span>&#123;</span><br><span class="line">        t.setUnlocked();</span><br><span class="line">        t.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pass</span><span class="params">(Turnstile t)</span> </span>&#123;</span><br><span class="line">        t.alarm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnlockedTurnstileState</span> <span class="keyword">implements</span> <span class="title">TurnstileState</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>这里展示了TurnstileState接口和它的两个派生类，在这两个派生类的4个方法中可以容易地对状态机进行访问。例如，LockedTurnstileState的coin方法让Turnstile对象把状态改变到unlocked，然后再调用Turnstile的unlock动作函数。</p>
<p>接下来就是状态机本体Turnstile类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Turnstile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TurnstileState lockedState = <span class="keyword">new</span> LockedTurnstileState();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TurnstileState unlockedState = <span class="keyword">new</span> UnlockedTurnstileState();</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> TurnstileState state = lockedState;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.coin(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pass</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        state.pass(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里展示了Turnstile类，把TurnstileState的派生类实例保存到成员变量中，避免每次状态变化都去创建新的实例。使用static将这些变量声明为静态，是为了当我们需要多个Turstile实例时，不必每次都创建新的状态派生类实例。</p>
<p>STATE模式彻底分离了状态机的逻辑和动作，动作式再Context中实现的，而逻辑则分布在State类的派生类中。这就使得二者可以非常容易地独立变化、互不影响。例如，只要使用State类的另一个派生类，就可以非常容易地在一个不同的状态逻辑中重用Context类的动作。此外，我们也可以在不影响State派生类逻辑的情况下创建Context的子类来更改或者替换动作的实现。</p>
<p>该方式的另一个好处是，它的效率和嵌套switch/case一样。因此该方法既具有表驱动方法的灵活性，又具有嵌套switch/case的高效率。</p>
<p>但是使用模式也是有代价的，其代价就是无法在一个地方清楚的看清楚整个状态机的逻辑，这就是模式带来的编码和维护上的好处和可观看性上的弊端，如同Template模式一样，将算法本体和函数抽象实现解耦，使得算法可以重用，但是在可阅读性上就大打折扣了。</p>

	
	</div>
  <a type="button" href="/2018/06/21/我理解的PPP-有限状态机和STATE模式/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/06/15/Optional类中三组方法的比较/" title="Java 8引入了Lambda表达式，以及Stream类表示流式处理，在max()，min()等函数中返回的就是Optional对象，Optional帮助Java实现了函数式编程。">Optional类中三组方法的比较</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-06-15  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>Optional不仅帮助Java实现函数式编程，还顺带解决了臭名昭著的空指针问题。其实解决空指针问题的思路都类似，如我之前写的这篇文章，<a href="https://ytying.com/2018/06/10/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84PPP-NULL%20OBJECT%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">我理解的PPP-NULL OBJECT模式</a>，无论是通过重写get(）方法，还是实现一个空对象，以及Optional将value包装起来，避免的都是同一个问题：对null的调用。这里讨论一下Optional中三组很相似的方法。先假设一个场景，有个方法返回了Optional包装的String对象，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Optional.ofNullable(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"hi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="orElse和orElseGet"><a href="#orElse和orElseGet" class="headerlink" title="orElse和orElseGet"></a>orElse和orElseGet</h6><p>先看这个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional opt = getHello();</span><br><span class="line"></span><br><span class="line">String orElseRes = opt.orElse(createString());</span><br><span class="line">String orElseGetRes = opt.orElseGet(() -&gt; createString());</span><br></pre></td></tr></table></figure></p>
<p>看似没有什么不同，如果opt中的value不为空，则返回value，如果为空则返回createString()方法新创建的字符串，但仔细看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会发现，orElse的参数是T other，orElseGet的参数是一个Lambda表达式，区别就在于，orElse在参数被赋值进去的时候，就已经将createString()函数执行拿到结果，而orElseGet这个Lambda表达式是在三目运算符匹配失败时才会延迟执行。所以虽然两者功能差不多，但是在orElseGet的性能毋庸置疑要优于orElse。</p>
<h6 id="isPresent和ifPresent"><a href="#isPresent和ifPresent" class="headerlink" title="isPresent和ifPresent"></a>isPresent和ifPresent</h6><p>这两个方法很简单，直接看源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中isPresent()单纯判断其包装的value是不是null，返回布尔类型，而ifPresent(Consumer&lt;? super T&gt; consumer)则接收一个void accpet(T t)的Lambda表达式，如果value不为null，则执行这个Lambda表达式。</p>
<h6 id="map和flatmap"><a href="#map和flatmap" class="headerlink" title="map和flatmap"></a>map和flatmap</h6><p>在Stream类中也有map和flatmap，其map是将每一个Stream中的每一个元素转换为另一个元素，而flatmap可以操作更深一层的Stream。而Optional的flatmap似乎不太一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Optional的map方法接收的是一个Function&lt;? super T, ? extends U&gt;的mapper，当value不为null的时候，将mapper.apply(value)的值包装到一个新的Optional中返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而Optional的flatmap方法，注意看Function的范型，是Function&lt;? super T, Optional<u>&gt;，已经限定了是一个Optional类型的返回值，所以直接返回mapper.apply(value)就行了。</u></p>
<p>其实我并没有看出来map和flatmap有什么太大的差异，一个包装了一下，一个直接返回Optional，可能是我对函数式编程的理解不够深，等我阅读完Richard Warburton的《Java 8函数式编程》之后再回头来看，可能会有不一样的体会，端午快乐～</p>

	
	</div>
  <a type="button" href="/2018/06/15/Optional类中三组方法的比较/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/06/12/非常生动的一张描述JOIN的图/" title="一个统计需求，join了七张表，一会inner，一会left，幸好有这张神图">非常生动的一张描述JOIN的图</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-06-12  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>JOIN分为内连接（inner join），外连接（outer join），左连接（left join），右连接（right join），自然连接（nature join），大致就是哪个当左表，哪个当右表，排除什么，不排除什么，哪个为空，哪个不为空。</p>
<p>总之，直接参考下图就可以了，简单易懂不混淆：<br><img src="https://ytying.com/img/join.png" alt="join示意图"></p>

	
	</div>
  <a type="button" href="/2018/06/12/非常生动的一张描述JOIN的图/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/06/10/我理解的PPP-NULL OBJECT模式/" >我理解的PPP-NULL OBJECT模式</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-06-10  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>15年在学校创业团队中做过Android开发，因为在app中碰到空指针等运行时异常会导致程序闪退，当时开发环境简陋，没有持续集成、回归测试等保证软件质量的手段，往往就只有自测、众测，为了解决闪退率高的问题，我用了一种对象上get()方法重写的方式回避了空指针引用链的hack手段，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == name) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过给一些基本类型的包装类型返回一个默认值，如果是PO类就调用构造方法构造一个空的，在当时用友盟统计来看，极大的降低了闪退率。</p>
<p>后来去阿里实习的时候，看到代码充斥着大量的<code>if (obj != null)</code>这样的代码，我分享过这种给Model类中get()方法返回默认值的方式，但因为可定制性不高，如果要在代码逻辑中有一些特殊判断往往就不能满足，就没有采用。</p>
<p>而NULL OBJECT模式其实跟上述手段有很大相似，都是为了避免代码中的<code>if (obj != null)</code>这样的代码，旨在消除对null进行检查的需要，有助于简化代码。</p>
<p>在这种模式中，一个类会变成具有两个实现的接口，一个是正常的实现，它包含了对象被期望的所有方法和变量，而另一个是NULL实现，也实例化了这个接口，但是不做任何实现，在使用的时候，如果满足预期则初始化正常的实现，如果在异常之中或者意料之外的情况，就返回NULL实例，这样在承接这个对象的地方就可以不用做任何判断而直接使用这个对象。具体的错误信息和日志信息可以打在NULL实现的各个重写方法中。</p>

	
	</div>
  <a type="button" href="/2018/06/10/我理解的PPP-NULL OBJECT模式/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/06/07/ThreadLocal中的Lambda表达式/" >ThreadLocal中的Lamdba表达式</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-06-07  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>ThreadLocal类作为容器保存了当前线程里局部变量的值，在jdk1.8中，引入了Lambda表达式，相应的为ThreadLocal类也添加了一个工厂方法，接受一个Lambda表达式，并产生一个新的ThreadLocal对象，使语法更简洁。</p>
<p>比如要创建一个线程安全的DateFormatter类，使用传统方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;DateFormatter&gt; formatterHolder = <span class="keyword">new</span> ThreadLocal&lt;DateFormatter&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> DateFormatter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DateFormatter(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"dd-MMM-yyyy"</span>)); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果使用Lambda表达式创建ThreadLocal，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;DateFormatter&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> DateFormatter(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"dd-MMM-yyyy"</span>)));</span><br></pre></td></tr></table></figure></p>
<p>看看源码是怎么做的，ThreadLocal的<code>withInitial(Supplier&lt;? extends S&gt; supplier)</code>方法接收一个Supplier的参数，然后new了一个<code>SuppliedThreadLocal&lt;&gt;(supplier)</code>，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个<code>SuppliedThreadLocal</code>又是什么呢，跟下去看到是一个继承了ThreadLocal的内部类，重写了initialValue()方法，将supplier.get()作为结果返回：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An extension of ThreadLocal that obtains its initial value from</span></span><br><span class="line"><span class="comment"> * the specified &#123;<span class="doctag">@code</span> Supplier&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppliedThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class="line"></span><br><span class="line">    SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class="line">        <span class="keyword">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就清楚了，其实是利用了Lambda表达式语法的简洁，但实际发生的操作一点都没少。</p>
<p>另外今天2018高考，如果能重来我要上北大，笑哭～</p>

	
	</div>
  <a type="button" href="/2018/06/07/ThreadLocal中的Lambda表达式/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/06/02/我理解的PPP-SINGLETON模式和MONOSTATE模式/" title="这两个模式都是强制对象单一性的模式">我理解的PPP-SINGLETON模式和MONOSTATE模式</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-06-02  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>其实单例模式只是表达我们的一种意图，一种不想你初始化多个对象的意图，而这个意图完全可以在编码中硬实现，在初始化应用程序时，只创建每个对象的一个实例，然后就使用该实例。</p>
<h6 id="SINGLETON模式"><a href="#SINGLETON模式" class="headerlink" title="SINGLETON模式"></a>SINGLETON模式</h6><p>Singleton没有公有构造函数，不使用getInstance()方法，就无法获得它的实例。</p>
<p>Singleton分为懒汉模式和饿汉模式，其中饿汉模式是类一旦加载，就把单例初始化完成，保证了getInstance()的时候，单例已经是存在的，不管以后会不会使用这个单例，都会占据一定的内存，但是相应的在第一次使用的速度也会更快；懒汉模式只有当调用getInstance()的时候，才会去初始化这个单例。故饿汉模式天生就是线程安全的，而懒汉模式需要自己保证线程安全。</p>
<p>饿汉模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>懒汉模式：(懒汉模式大致有三种写法)<br>1、synchronized同步锁getInstance()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、double check双重检查锁定<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、静态内部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="MONOSTATE模式"><a href="#MONOSTATE模式" class="headerlink" title="MONOSTATE模式"></a>MONOSTATE模式</h6><p>MonoState翻译为单态，是另一种获取对象单一性的方法，它使用了和Singleton模式完全不同的工作机制，两个MonoState对象共享相同的变量，这一点很容易办到，只要把所有变量都变成静态变量即可，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">MonoState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> itsX = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		itsX = x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> itsX;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样通过一个static的变量itsX，无论构造多少个对象，都会表现的像一个对象一样。</p>
<h6 id="Singleton和MONOSTATE的区别"><a href="#Singleton和MONOSTATE的区别" class="headerlink" title="Singleton和MONOSTATE的区别"></a>Singleton和MONOSTATE的区别</h6><p>这两个模式的区别在于，Singleton模式更关注结构上的单一性，它会防治创建出多个对象实例；而MonoState模式则强制行为上的单一性，没有结构方面的限制。基于这点可以考虑如下：MonoState的场景一般都适用于Singleton，而Singleton的场景未必适用于MonoState。</p>

	
	</div>
  <a type="button" href="/2018/06/02/我理解的PPP-SINGLETON模式和MONOSTATE模式/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/05/29/nio中的多路复用IO模型/" >nio中的多路复用IO模型</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-05-29  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>前段时间写过一篇<a href="https://ytying.com/2018/04/28/%E4%B8%BA%E4%BB%80%E4%B9%88OpenResty%E6%80%A7%E8%83%BD%E5%A5%BD/" target="_blank" rel="noopener">《为什么OpenResty性能好》</a>阐述了在linux下使用epoll模型来提升nginx的io处理能力，今天看了一篇讲java中io演进的过程的文章，发现nio中的Selector同样使用了epoll去处理大量连接（其实是select-windows，kqueue-freebsd，epoll-linux）。</p>
<p>在通过<code>Selector.open()</code>创建Selector的时候，会执行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectorProvider.provider().openSocketChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看provider()方法，重点是<code>provider = sun.nio.ch.DefaultSelectorProvider.create()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我是mac，所以使用的是macOS版本的jdk，其DefaultSelectorProvider使用的是KQueueSelectorProvidor，如果是linux版本的jdk，默认SelectorProvidor使用的就是EpollSelectorProvidor，不过说白了都是多路复用io模型，用云风一篇博客<a href="https://blog.codingnow.com/2006/04/iocp_kqueue_epoll.html" target="_blank" rel="noopener">《IOCP , kqueue , epoll … 有多重要？》</a>里面说的：</p>
<blockquote>
<p>select模型叫鬼子进村策略，一遍遍的询问“鬼子进村了吗？”，“鬼子进村了吗？”… 大量的 cpu 时间都耗了进去。使用 kqueue 这些，变成了派一些个人去站岗，鬼子来了就可以拿到通知，效率自然高了许多。</p>
</blockquote>
<p>特别有意思，这里KQueueSelectorProvider的openSelector()方法返回了KQueueSelectorImpl实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractSelector <span class="title">openSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KQueueSelectorImpl(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在代码中使用<code>selector.select()</code>或它的几个重载方法，通过Selector选择通道时，这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。这里就会调用到KQueueSelectorImpl（或者其他的XXSelectorImpl）重写父类的doSelect(long var1)方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> var3 = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.processDeregisterQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> var7;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.begin();</span><br><span class="line">            var7 = <span class="keyword">this</span>.kqueueWrapper.poll(var1);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.end();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.processDeregisterQueue();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.updateSelectedKeys(var7);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中重点就是<code>KqueueWrapper.poll(var1)</code>啦，这个KQeueueArrayWrapper就是jdk实现Kqueue模型的代码了，Kqueue模型我没研究过就不bb了，有时间可以去看一下linux下jdk的EPollArrayWrapper的实现～</p>
<p>最后，云大的这篇<a href="https://blog.codingnow.com/2006/04/iocp_kqueue_epoll.html" target="_blank" rel="noopener">《IOCP , kqueue , epoll … 有多重要？》</a>写在2006年，想法是通过在游戏服务器和客户端之间加一层连接服务器，连接服务器做的事情可以非常简单，只是把多个连接上的数据汇集到一起。假设同时连接总数不超过 65536 个，我们只需要把每个连接上的数据包加上一个两字节的数据头就可以表识出来。这个连接服务器再通过单个连接和逻辑服务器通讯就够了。这样做，游戏服务器对网络层的代码量的需求也大大减少了，可以更专心的构建逻辑。也能更方便的移植到不同系统上而不用考虑各系统间不同且负责的网络代码了。云大的思想真的是超前啊，每次看到他在我小学几年级写的博客，都有种眼界大开的感觉～</p>

	
	</div>
  <a type="button" href="/2018/05/29/nio中的多路复用IO模型/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/05/26/我理解的PPP-STRATEGY模式/" title="STRATEGY模式使用委托来倒置通用算法和具体实现之间的依赖关系">我理解的PPP-STRATEGY模式</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-05-26  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h6 id="Strategy模式介绍"><a href="#Strategy模式介绍" class="headerlink" title="Strategy模式介绍"></a>Strategy模式介绍</h6><p>Strategy策略模式和Template模版模式很像，但最大的区别是Template模式的派生类不可避免地和模版类绑定在一起，使得子类中的方法无法重用，而Strategy模式使用委托的手段不直接建立模版类和实现类之间的关系，而是通过对接口的委托来实现模版类和派生类的分离，可以参考如下类图：<br><img src="https://ytying.com/img/strategy.png" alt="strategy模式类图"><br>可以看到BubbleSorter通过组合的方式引入一个SortHandle接口，而SortHandle接口中正包含BubbleSorter所需要的那几个模版方法，所以IntBubbleSorter只需实现SortHandle接口后，就能够组合出BubbleSorter来，不仅如此，IntBubbleSorter甚至还可以提供给其它模版类使用，比如一个改进版的QuickBubbleSorter，它在一次对于数组的遍历中发现数组元素已经是有序的，就提前结束。</p>
<h6 id="jdk中的Strategy模式"><a href="#jdk中的Strategy模式" class="headerlink" title="jdk中的Strategy模式"></a>jdk中的Strategy模式</h6><p>典型的策略模式在jdk中的实现就是Collection.sort()方法，它使用Comparator对象作为参数，根据Comparator接口的不同实现，对象会以不同方式进行排序。</p>

	
	</div>
  <a type="button" href="/2018/05/26/我理解的PPP-STRATEGY模式/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
           <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>Prev</a>
        

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/2/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<div class="col-md-3">
    <h6>本站总访问量<span id="busuanzi_value_site_pv"></span>次</h6>
	<br/>
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/OpenResty/">OpenResty<span>2</span></a></li>
		
			<li><a href="/categories/PPP/">PPP<span>8</span></a></li>
		
			<li><a href="/categories/jvm/">jvm<span>5</span></a></li>
		
			<li><a href="/categories/python/">python<span>1</span></a></li>
		
			<li><a href="/categories/深入学习java/">深入学习java<span>6</span></a></li>
		
			<li><a href="/categories/瞎搞/">瞎搞<span>3</span></a></li>
		
			<li><a href="/categories/解bug之路/">解bug之路<span>2</span></a></li>
		
		</ul>
	</div>

		
			

		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2018/07/15/我理解的PPP-VISITOR模式和双重分发/"  title="需要向类层次结构中增加新的方法，但是增加起来会很费劲或者会破坏设计。" ><i class="fa fa-file-o"></i>我理解的PPP-VISITOR模式和双重分发</a>
      </li>
    
      <li>
        <a href="/2018/07/02/python2.7不支持SNI引发的问题/" ><i class="fa fa-file-o"></i>python2.7不支持SNI引发的问题</a>
      </li>
    
      <li>
        <a href="/2018/06/21/我理解的PPP-有限状态机和STATE模式/"  title="有限状态机是现实生活中很多模型的抽象，能利用好有限状态机模型能将很多复杂的逻辑清晰的表述出来" ><i class="fa fa-file-o"></i>我理解的PPP-有限状态机和STATE模式</a>
      </li>
    
      <li>
        <a href="/2018/06/15/Optional类中三组方法的比较/"  title="Java 8引入了Lambda表达式，以及Stream类表示流式处理，在max()，min()等函数中返回的就是Optional对象，Optional帮助Java实现了函数式编程。" ><i class="fa fa-file-o"></i>Optional类中三组方法的比较</a>
      </li>
    
      <li>
        <a href="/2018/06/12/非常生动的一张描述JOIN的图/"  title="一个统计需求，join了七张表，一会inner，一会left，幸好有这张神图" ><i class="fa fa-file-o"></i>非常生动的一张描述JOIN的图</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-cube"></i><a href="http://java.ytying.com" title="My Java compiler" target="_blank"]);">我的Java在线编译器</a></li>
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/UKfire" title="My Github account." target="_blank"]);">My Github</a></li>
	
		<li><i class="fa fa-share"></i><a href="https://blog.codingnow.com" title="云风的 BLOG" target="_blank"]);">云风的 BLOG</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2018 kefan.wkf
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.   Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 




   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
